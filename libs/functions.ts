import asyncExitHook from 'async-exit-hook';
import { Request, Response } from 'express';
import fs from "fs";
import path from "path";
import consola, { LogLevels } from "consola";
import { _version } from "#hostweb";
import showdown from "showdown";
import express from 'express';
import chalk from "chalk";
import { Server } from "http";
import { parse, stringify } from "ini";
import { dirname, filename } from 'dirname-filename-esm';
import { glob } from 'glob';
import { HWBuilder } from '#classes';
import { createGunzip } from 'zlib';
import temp from 'temp';
import { promisify } from 'util';
import { pipeline } from 'stream';
import { HTMLElement, parse as parsehtml } from 'node-html-parser';
import e from 'express';
const __dirname = dirname(import.meta);
const __filename = filename(import.meta);
export async function serve(filename: string, raw: boolean) {
    let content: string | Buffer = '';
    const extension = path.extname(filename).toLowerCase(); // Pobieranie rozszerzenia pliku
    if (raw) {
        consola.info('Using raw mode. Formatting disabled.');
    }
    consola.start(`Invoking server for "${path.resolve(filename)}"...\n`);

    // Sprawdzanie, czy plik istnieje
    if (!fs.existsSync(filename) || !fs.statSync(filename).isFile()) {
        consola.error(`This is not a file or it doesn't exist: ${path.resolve(filename)}`);
        return;
    }

    const app = express();

    // Obsługa plików w zależności od rozszerzenia
    switch (extension) {
        case '.md':  // Obsługa plików Markdown
            if (!raw) {
                consola.start('Converting markdown...');
                const converter = new showdown.Converter();
                let body = converter.makeHtml(fs.readFileSync(filename, 'utf8'));
                content = `
                <!-- Generated by HostWeb v${_version} -->
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${filename}</title>
                    <style>
                        @font-face {
                            font-family: 'CustomFont';
                            src: url('../assets/fonts/leaguespartan.ttf') format('truetype');
                        }
                        body {
                            font-family: 'CustomFont', sans-serif;
                        }
                    </style>
                </head>
                <body>
                    ${body}  <!-- Zawartość markdown jako HTML -->
                </body>
                </html>
                `;
                consola.success('Markdown conversion done!');
            } else {
                content = fs.readFileSync(filename);  // Odczyt pliku w trybie "raw"
            }
            break;

        case '.html':  // Obsługa plików HTML
        case '.htm':
            content = fs.readFileSync(filename);  // Odczyt zawartości HTML
            break;

        case '.hw':  // Obsługa plików .hw (HostWeb)
            let filepath: string;
            if (isGzipFile(filename)) {  // Jeśli plik jest skompresowany Gzipem
                filepath = temp.path({ suffix: '.hwunpacked' });
                try {
                    await decompressGzipFile(filename, filepath);  // Dekompresja pliku
                } catch (error) {
                    consola.error('Error during decompression:', error);
                    return;
                }
            } else {
                filepath = filename;
            }

            const config = JSON.parse(fs.readFileSync(filepath, 'utf8'));  // Odczyt JSON z pliku .hw

            // Serwowanie pliku głównego (index.html)
            app.get("/", (req: Request, res: Response) => {
                if (config['#'] && config['#']['index.html']) {
                    res.setHeader('Content-Type', 'text/html');
                    res.send(config['#']['index.html'].content);
                } else {
                    res.status(404).send('Index.html not found in .hw file');
                }
            });

            // Serwowanie dynamicznych tras
            Object.keys(config['#']).forEach((route) => {
                let routePath: string;

                // Obsługa dynamicznych tras dla plików index.html
                if (route.toLowerCase() === "index.html" || route.toLowerCase() === "index.htm") {
                    routePath = "/";
                } else if (route.endsWith('/index.html') || route.endsWith('/index.htm')) {
                    routePath = `/${route.replace('/index.html', '').replace('/index.htm', '')}`;
                } else {
                    routePath = `/${route}`;
                }

                app.get(routePath, (req: Request, res: Response) => {
                    if (config['#'][route] && config['#'][route].content) {
                        res.setHeader('Content-Type', 'text/html');
                        res.send(config['#'][route].content);
                    } else {
                        res.status(404).send(`${route} not found in .hw file`);
                    }
                });
            });

            // Serwowanie zasobów z folderu .assets
            app.get('/.assets/:file', (req: Request, res: Response) => {
                const requestedAsset = req.params.file;
                if (config.assets && config.assets[requestedAsset]) {
                    const assetContent = config.assets[requestedAsset].content;
                    const assetEncoding = config.assets[requestedAsset].encoding || 'utf8';  // Sprawdzenie kodowania

                    if (assetEncoding === 'base64') {
                        res.setHeader('Content-Type', getContentType(requestedAsset));
                        const buffer = Buffer.from(assetContent, 'base64');  // Dekodowanie Base64 do bufora
                        res.send(buffer);
                    } else {
                        res.setHeader('Content-Type', getContentType(requestedAsset));
                        res.send(assetContent);  // Wyślij jako tekst
                    }
                } else {
                    res.status(404).send('Asset not found');
                }
            });
            break;

        default:  // Domyślna obsługa innych typów plików
            content = fs.readFileSync(filename);
    }

    if (extension != '.hw' || (extension == '.hw' && raw)) {
        let fileexts = JSON.parse(fs.readFileSync(path.resolve(path.join(path.dirname(__dirname), 'assets', 'json', 'fileext.json')), 'utf8'));
        app.get('/', (req: Request, res: Response) => {
            if (raw) {
                res.setHeader('Content-Type', 'text/plain');
            } else {
                res.contentType(fileexts[extension] || 'text/plain');
            }
            res.send(content);
        });
    }

    if (['.html', '.htm', '.md'].includes(extension)) {
        const parsedHTML = parsehtml(content.toString());  //  Parsowanie zawartości HTML
        const assets: any = [];
        if (parsedHTML.querySelectorAll('img, script, link[rel="stylesheet"]').length > 0) {
            consola.info('External assets detected! Serving to static server...');
        }
        // Zbieranie zasobów (obrazy, skrypty, style)
        parsedHTML.querySelectorAll('img, script, link[rel="stylesheet"]').forEach((element: HTMLElement) => {
            let srcAttr = element.getAttribute('src') || element.getAttribute('href');
            if (srcAttr) {
                const assetPath = path.join(path.dirname(filename), srcAttr);
                if (fs.existsSync(assetPath)) {
                    assets.push(assetPath);
                }
            }
        });

        // Serwowanie zasobów dynamicznie 
        assets.forEach((asset: string) => {
            app.get('/' + asset, (req: Request, res: Response) => {
                res.send(fs.readFileSync(asset)); 
            }); 
        });
    }

    // Uruchomienie serwera
    app.set('view engine', 'ejs');
    app.set('views', path.resolve(path.join(path.dirname(__dirname), 'htmls')));
    const server: Server = app.listen(825, () => {
        consola.log('');
        consola.info(`Serving file: ${chalk.green(filename)}`);
        consola.info(chalk.blue(`http://localhost:825`));
        consola.info(`Press ${chalk.green("Ctrl+C")} to stop...`);
        asyncExitHook(async (done) => {
            consola.info('Stopping server...');
            server.close();
            done();
        });
        
        
    });

    app.use((req: Request, res: Response, next) => {
        res.set("X-Powered-By", "HostWeb");
        next();
    }); 

    // Obsługa błędów 404
    app.use((req: Request, res: Response) => {
        res.status(404).render('404', { version: _version, adress: req.url });
    });
}


export async function create(projname: string) {
    consola.start('Invoked project creation...');
    if (projname == '.') {
        let currdir = await consola.prompt("Generate project in current directory?", { type: 'confirm' });
        if (!currdir) {
            process.exit(0);
        } else if (currdir) {
            if ((await glob('*', { cwd: process.cwd() })).length > 0) {
                consola.error(`Directory is not empty: ${process.cwd()}`);
                process.exit(0);
            }
        }
    }
    if (fs.existsSync(projname) && projname != '.') {
        consola.error(`Directory already exists: ${projname}`);
        process.exit(0);
    }
    if (projname != '.') {
        fs.mkdirSync(projname, { recursive: true });
    }
    fs.mkdirSync(path.join(projname, 'src'), { recursive: true });
    fs.mkdirSync(path.join(projname, 'src', 'example-route'), { recursive: true });
    fs.mkdirSync(path.join(projname, 'src','.assets'), { recursive: true });
    fs.writeFileSync(path.join(projname, 'src','example-route',  'index.html'), '<h1>Hello World</h1>\n<p>This is example route</p>\n', 'utf8');
    fs.writeFileSync(path.join(projname, 'src','index.html'), '<h1>Hello World</h1>\n<p>This is homepage</p>\n', 'utf8');
    fs.writeFileSync(path.join(projname, 'src','.assets', 'style.css'), '/* This is an example stylesheet */\nbody { background-color: #f2f2f2; }', 'utf8');
    fs.writeFileSync(path.join(projname, 'src','README.md'), `# ${projname == '.' ? path.basename(process.cwd()) : projname}
Welcome in ${projname == '.' ? path.basename(process.cwd()) : projname} project!

## Useful commands

### build
\`hostweb build\` - Build project

<hr>
<center>HostWeb v${_version}</center>`, 'utf8');
    fs.writeFileSync(path.join(projname, '.hostwebrc'), stringify({
        file: "hostwebrc",
        config: {
            name: projname == '.' ? path.basename(process.cwd()) : projname, 
            build: {
                type: "classic",
                usegzip: true,
                minify: true
            },
            ignore: [
                "README.md"
            ] 
        },
    }), 'utf8');
    consola.success('Project created successfully! 🎉');
}

export async function build(out: string, debug: boolean) {
    let config: any;
    consola.level = debug ? LogLevels.debug : LogLevels.info;
    if (debug) consola.debug('Debug mode enabled!');
    consola.start('Invoked project build...');
    if (debug) consola.debug('Parsing config...'); 
    if (!fs.existsSync('./.hostwebrc')) {
        consola.error('Cannot find config (.hostwebrc) file!');
        process.exit(0);
    }
    try {
        config = parse(fs.readFileSync('./.hostwebrc', 'utf8'));
        if (debug) consola.debug('Invoking HWBuilder...');
        const hwb = new HWBuilder();
        await hwb.createHWFile(process.cwd(), path.join(out, config.config.name + '.hw'), config.config.ignore, config.config.build.usegzip, debug, config.config.build.minify);
    } catch (error) {
        consola.error(error);
        process.exit(0);
    }
    consola.success(chalk.green('Project builded successfully! 🎉'));
    consola.info('Check it out by running: ' + chalk.blueBright(`hostweb serve ./${out}/${config.config.name}.hw`)); 
}

export function isGzipFile(filePath: string) {
    const buffer = Buffer.alloc(2); // Pierwsze dwa bajty
    const fileDescriptor = fs.openSync(filePath, 'r');
    fs.readSync(fileDescriptor, buffer, 0, 2, 0);
    fs.closeSync(fileDescriptor);

    // Sprawdź czy pierwsze dwa bajty są zgodne z Gzip (0x1f 0x8b)
    return buffer[0] === 0x1f && buffer[1] === 0x8b;
}

const pipelineAsync = promisify(pipeline);

export async function decompressGzipFile(filePath: string, outPath: string): Promise<void> {
    try {
        const readStream = fs.createReadStream(filePath);
        const writeStream = fs.createWriteStream(outPath);
        const unzip = createGunzip();

        // Używamy promisify do pipeline, aby obsługiwać strumienie asynchronicznie
        await pipelineAsync(readStream, unzip, writeStream);
    } catch (err) {
        consola.error(err);
        throw err;
    }
}

export function getContentType(fileName: string): string {
    const ext = path.extname(fileName).toLowerCase();
    const exts = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'assets', 'json', 'fileext.json'), 'utf8'));
    return exts[ext] || 'text/plain';
}
 