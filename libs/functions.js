import fs from "fs";
import path from "path";
import consola, { LogLevels } from "consola";
import { _version } from "#hostweb";
import showdown from "showdown";
import express from 'express';
import chalk from "chalk";
import { parse, stringify } from "ini";
import { dirname, filename } from 'dirname-filename-esm';
import { glob } from 'glob';
import { HWBuilder } from '#classes';
import { createGunzip } from 'zlib';
import temp from 'temp';
import { promisify } from 'util';
import { pipeline } from 'stream';
const __dirname = dirname(import.meta);
const __filename = filename(import.meta);
export async function serve(filename, raw) {
    let content = '';
    const extension = path.extname(filename).toLowerCase();
    if (raw) {
        consola.info('Using raw mode. Formatting disabled.');
    }
    consola.start(`Invoking server for "${filename}"...`);
    if (!fs.existsSync(filename) || !fs.statSync(filename).isFile()) {
        consola.error(`This is not a file or it doesn't exist: ${filename}`);
        return;
    }
    const app = express();
    switch (extension) {
        case '.md':
            if (!raw) {
                consola.start('Converting markdown...');
                const converter = new showdown.Converter();
                let body = converter.makeHtml(fs.readFileSync(filename, 'utf8'));
                content = `
                <!-- Generated by HostWeb v${_version} -->
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${filename}</title>
                    <style>
                        @font-face {
                            font-family: 'CustomFont';
                            src: url('../assets/fonts/leaguespartan.ttf') format('truetype');
                        }
    
                        body {
                            font-family: 'CustomFont', sans-serif;
                        }
                    </style>
                </head>
                <body>
                    ${body}  <!-- Converted HTML content is placed here -->
                </body>
                </html>
                `;
                consola.success('Markdown conversion done!');
            }
            else {
                content = fs.readFileSync(filename, 'utf8');
            }
            break;
        case '.html':
        case '.htm':
            content = fs.readFileSync(filename, 'utf8');
            break;
        case '.hw':
            let filepath;
            if (isGzipFile(filename)) {
                filepath = temp.path({ suffix: '.hwunpacked' });
                try {
                    await decompressGzipFile(filename, filepath);
                }
                catch (error) {
                    consola.error('Error during decompression:', error);
                    return;
                }
            }
            else {
                filepath = filename;
            }
            const config = JSON.parse(fs.readFileSync(filepath, 'utf8'));
            app.get("/", (req, res) => {
                if (config['#'] && config['#']['index.html']) {
                    res.setHeader('Content-Type', 'text/html');
                    res.send(config['#']['index.html'].content);
                }
                else {
                    res.status(404).send('Index.html not found in .hw file');
                }
            });
            app.get('/.assets/:file', (req, res) => {
                const requestedAsset = req.params.file;
                if (config.assets && config.assets[requestedAsset]) {
                    res.setHeader('Content-Type', getContentType(requestedAsset));
                    res.send(config.assets[requestedAsset].content);
                }
                else {
                    res.status(404).send('Asset not found');
                }
            });
            break;
        default:
            content = fs.readFileSync(filename, 'utf8');
    }
    app.set('view engine', 'ejs');
    app.set('views', path.resolve(path.join(path.dirname(__dirname), 'htmls')));
    const server = app.listen(825, () => {
        consola.log('');
        consola.info(`Serving file: ${chalk.green(filename)}`);
        consola.info(chalk.blue(`http://localhost:825`));
        consola.info(`Press ${chalk.green("Ctrl+C")} to stop...`);
    });
    app.use((req, res, next) => {
        res.set("X-Powered-By", "HostWeb");
        next();
    });
    app.use((req, res) => {
        res.status(404).render('404', { version: _version, adress: req.url });
    });
}
export async function create(projname) {
    consola.start('Invoked project creation...');
    if (projname == '.') {
        let currdir = await consola.prompt("Generate project in current directory?", { type: 'confirm' });
        if (!currdir) {
            process.exit(0);
        }
        else if (currdir) {
            if ((await glob('*', { cwd: process.cwd() })).length > 0) {
                consola.error(`Directory is not empty: ${process.cwd()}`);
                process.exit(0);
            }
        }
    }
    if (fs.existsSync(projname)) {
        consola.error(`Directory already exists: ${projname}`);
        process.exit(0);
    }
    if (projname != '.') {
        fs.mkdirSync(projname, { recursive: true });
    }
    fs.mkdirSync(path.join(projname, 'src'), { recursive: true });
    fs.mkdirSync(path.join(projname, 'src', 'example-route'), { recursive: true });
    fs.mkdirSync(path.join(projname, 'src', '.assets'), { recursive: true });
    fs.writeFileSync(path.join(projname, 'src', 'example-route', 'index.html'), '<h1>Hello World</h1>\n<p>This is example route</p>\n', 'utf8');
    fs.writeFileSync(path.join(projname, 'src', 'index.html'), '<h1>Hello World</h1>\n<p>This is homepage</p>\n', 'utf8');
    fs.writeFileSync(path.join(projname, 'src', '.assets', 'style.css'), '/* This is an example stylesheet */\nbody { background-color: #f2f2f2; }', 'utf8');
    fs.writeFileSync(path.join(projname, 'src', 'README.md'), `# ${projname}
Welcome in ${projname} project!

## Useful commands

### build
\`hostweb build\` - Build project

<hr>
<center>HostWeb v${_version}</center>`, 'utf8');
    fs.writeFileSync(path.join(projname, '.hostwebrc'), stringify({
        file: "hostwebrc",
        config: {
            name: projname,
            build: {
                type: "classic",
                usegzip: true
            },
            ignore: [
                "README.md"
            ]
        },
    }), 'utf8');
    consola.success('Project created successfully! ðŸŽ‰');
}
export async function build(out, debug) {
    consola.level = debug ? LogLevels.debug : LogLevels.info;
    if (debug)
        consola.debug('Debug mode enabled!');
    consola.start('Invoked project build...');
    if (debug)
        consola.debug('Parsing config...');
    if (!fs.existsSync('./.hostwebrc')) {
        consola.error('Cannot find config (.hostwebrc) file!');
        process.exit(0);
    }
    try {
        const config = parse(fs.readFileSync('./.hostwebrc', 'utf8'));
        if (debug)
            consola.debug('Invoking HWBuilder...');
        const hwb = new HWBuilder();
        hwb.createHWFile(process.cwd(), path.join(out, config.config.name + '.hw'), config.config.ignore, config.config.build.usegzip, debug);
    }
    catch (error) {
        consola.error(error);
        process.exit(0);
    }
    consola.success(chalk.green('Project builded successfully! ðŸŽ‰'));
    consola.info('Check it out by running: ' + chalk.blueBright(`hostweb serve ./${out}/${parse(fs.readFileSync('./.hostwebrc', 'utf8')).config.name}.hw`));
}
export function isGzipFile(filePath) {
    const buffer = Buffer.alloc(2);
    const fileDescriptor = fs.openSync(filePath, 'r');
    fs.readSync(fileDescriptor, buffer, 0, 2, 0);
    fs.closeSync(fileDescriptor);
    return buffer[0] === 0x1f && buffer[1] === 0x8b;
}
const pipelineAsync = promisify(pipeline);
export async function decompressGzipFile(filePath, outPath) {
    try {
        const readStream = fs.createReadStream(filePath);
        const writeStream = fs.createWriteStream(outPath);
        const unzip = createGunzip();
        await pipelineAsync(readStream, unzip, writeStream);
    }
    catch (err) {
        consola.error(err);
        throw err;
    }
}
export function getContentType(fileName) {
    const ext = path.extname(fileName).toLowerCase();
    switch (ext) {
        case '.css':
            return 'text/css';
        case '.js':
            return 'application/javascript';
        default:
            return 'text/plain';
    }
}
